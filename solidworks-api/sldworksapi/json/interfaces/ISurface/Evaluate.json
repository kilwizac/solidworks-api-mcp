{
  "frontmatter": {
    "type": "method",
    "interface": "ISurface",
    "member": "Evaluate",
    "returns": "System.Object",
    "parameters": [
      {
        "name": "UParam",
        "type": "System.Double",
        "description": "Value of u parameter"
      },
      {
        "name": "VParam",
        "type": "System.Double",
        "description": "Value of v parameter"
      },
      {
        "name": "NumUDeriv",
        "type": "System.Int32",
        "description": "Number of u derivatives required"
      },
      {
        "name": "NumVDeriv",
        "type": "System.Int32",
        "description": "Number of v derivatives required"
      }
    ],
    "docset": "sldworksapi",
    "deprecated": false,
    "since_version": "unknown",
    "categories": [
      "documents"
    ],
    "related": [
      "ISurface.EvaluateAtPoint",
      "ISurface.IEvaluate",
      "ISurface.IEvaluateAtPoint",
      "ISurface.IReverseEvaluate",
      "ISurface.ReverseEvaluate"
    ],
    "keywords": [
      "evaluate",
      "isurface",
      "surface",
      "param",
      "double",
      "num",
      "deriv",
      "int32",
      "object",
      "create",
      "trimmed",
      "curve",
      "vba",
      "vb",
      "net"
    ]
  },
  "title": "ISurface.Evaluate",
  "description": "Evaluates the surface, given the u and v parameters of the surface.",
  "signature": "System.Object Evaluate( \n   System.Double\nUParam\n,\n   System.Double\nVParam\n,\n   System.Int32\nNumUDeriv\n,\n   System.Int32\nNumVDeriv\n)",
  "parameters": [
    {
      "name": "UParam",
      "type": "System.Double",
      "description": "Value of u parameter"
    },
    {
      "name": "VParam",
      "type": "System.Double",
      "description": "Value of v parameter"
    },
    {
      "name": "NumUDeriv",
      "type": "System.Int32",
      "description": "Number of u derivatives required"
    },
    {
      "name": "NumVDeriv",
      "type": "System.Int32",
      "description": "Number of v derivatives required"
    }
  ],
  "returns": "This method returns the evaluated point, normal, and derivatives with respect to u and v up to order NumUDerivs and NumVDerivs, respectively. If NumUDerivs and NumVDerivs are 0, then no derivatives are returned. For more information on the valid u and v parameters of the surface, see ISurface::Parameterization or ISurface::IParameterization . Also, use IFace2::FaceInSurfaceSense to check to see if the normal of the face is in the same direction or in the opposite direction of the surface normal. The evaluation returns the following array of (3 *((( NumUDerivs +1) * (N umVDerivs + 1)) + 1 )) doubles: [ evaluatedPoint [ 3 ] , evaluatedDerivatives [ xx ] , evaluatedNormal [ 3 ] ] where: evaluatedPoint [ 3 ] = point representing the evaluated X,Y,Z point in meters evaluatedDerivatives [ xx ] = array of vectors representing the derivatives where the n th derivative wrt u (i <= N umUDerivs ) and the n th derivative wrt v (j <= NumVDerivs ) would be vector number ( i + ( NumUDerivs + 1) * j ) - 1 in the evaluatedDerivatives array. If NumUDerivs and N umVDerivs are 0, then no derivatives are returned. evaluatedNormal [ 3 ] = a vector representing the evaluated normal The following table describes the number of derivatives that can be requested based on the surface type. If you request more derivatives than allowed, then this method returns all data as zeros. To determine the surface type, see ISurface::Identity . U Derivatives 0 1 2 0 a a b V Derivatives 1 a a c 2 b c d where : a - All surface types b - All surface types except blend surfaces c - All surface types except blend surfaces and offset surfaces d - All surface types except blend surfaces but offset surfaces will only return 0th, 1st, and 2nd derivatives (the uncalculated 3rd and 4th derivatives are returned as 0 vectors). For example, if you specified 2 derivatives in both u and v, then an array containing 10 vectors is returned. The returned data is in model space coordinates. [P(u,v) P(u,v)/du P(u,v)/dudu] [P(u,v)/dv P(u,v)/dudv P(u,v)/dududv] [P(u,v)/dvdv P(u,v)/dudvdv P(u,v)/dududvdv] [N(u,v)] where: du the partial derivative in the u direction dv the partial derivative in the v direction N(u,v) the normal vector Each P() represents a model space point or vector depending on the entry in the array If you request 2 derivatives for u and 1 for v, then an array containing 7 vectors is returned: [P(u,v) P(u,v)/du P(u,v)/dudu] [P(u,v)/dv P(u,v)/dudv P(u,v)/dududv] [N(u,v)] If u = 1 and v = 2, then: [P(u,v) P(u,v)/du] [P(u,v)/dv P(u,v)/dudv] [P(u,v)/dvdv P(u,v)/dudvdv] [N(u,v)]",
  "remarks": "",
  "examples": [
    {
      "title": "Create Trimmed Curve (VBA)",
      "href": "Return_Untrimmed_Curve_Example_VB.htm",
      "code_blocks": []
    },
    {
      "title": "Create Trimmed Curve (VB.NET)",
      "href": "Return_Untrimmed_Curve_Example_VBNET.htm",
      "code_blocks": []
    },
    {
      "title": "Create Trimmed Curve (C#)",
      "href": "Return_Untrimmed_Curve_Example_CSharp.htm",
      "code_blocks": []
    }
  ],
  "related": [
    "ISurface.EvaluateAtPoint",
    "ISurface.IEvaluate",
    "ISurface.IEvaluateAtPoint",
    "ISurface.IReverseEvaluate",
    "ISurface.ReverseEvaluate"
  ]
}